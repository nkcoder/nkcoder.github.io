---
title: "Java并发：读写锁ReadWriteLock"
date: 2020-10-23T08:18:57+08:00
categories:
- Java并发
draft: false
---
读写锁允许多个线程同时读，即线程的读读之间是不互斥的，只有线程的读写和写写之间才是互斥的。

如果系统中数据量很大，读操作远大于写操作，使用读写锁比使用普通的互斥锁，可以更好地提升系统性能。

```java
ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
```

读写锁的默认实现是`ReentrantReadWriteLock`，有如下特性：

- 公平性：
  - 默认非公平锁，即读写锁的获取顺序不定，所以可能会有线程长时间无法获取到锁。非公平锁的吞吐率比公平锁更高。
  - 公平锁，等待时间最长的线程优先获取锁。当锁被释放时，或者是等待时间最长的一个写线程获取到锁，或者是等待时间最长的一组读线程获取到锁。
- 可重入性：允许读线程/写线程以ReentrantLock的方式重新获取到读/写锁。写线程可以获取读锁，但是读线程不能获取写锁。
- 锁降级：可重入性允许写锁降级为读锁，即线程先获取写锁，然后获取读锁，然后释放写锁。但是读锁是不能升级为写锁的。
- 支持Condition：写锁可以像ReentrantLock一样使用ReentrantLock.newCondition，但是读锁不行。
- 该实现最大支持65535个递归的写锁和65536个读锁，超过限制会报错。
